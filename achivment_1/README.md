# AVR Ping-Pong Timers (ATmega8 @ 16 MHz)

Два «параллельных» таймера порождают строки в UART.  
Проект закрывает все уровни задания: стандартный, средний и высокий.

- **Стандарт:** два таймера; строки `"ping1"`/`"pong1"`; интервалы заданы константами.  
- **Средний:** детерминированный запуск передачи первого байта прямо из ISR таймера (джиттер ≤ 4 тактов); приведён расчёт минимальной суммы интервалов.  
- **Высокий:** команды по UART (без остановки таймеров) для изменения интервалов, строк и перезагрузки счётчиков; онлайн-проверка выполнимости, при ошибке — `ERR`.

---

## Содержание

- [Требования](#требования)
- [Функциональность](#функциональность)
- [Пины и подключение](#пины-и-подключение)
- [Сборка и прошивка](#сборка-и-прошивка)
- [Константы и конфигурация](#константы-и-конфигурация)
- [Команды по UART](#команды-по-uart)
- [Критерии выполнимости (проверка «на лету»)](#критерии-выполнимости-проверка-на-лету)
- [Точность ≤ 4 тактов (пояснение для «средней сложности»)](#точность-4-тактов-пояснение-для-средней-сложности)
- [Минимальная сумма интервалов](#минимальная-сумма-интервалов)
- [Ограничения и примечания](#ограничения-и-примечания)
- [Структура проекта](#структура-проекта)
- [Лицензия](#лицензия)

---

## Требования

- МК: **ATmega8** @ **16 MHz** (Arduino-совместимая плата подойдёт).
- UART: **115200 8N1**, двойная скорость (U2X=1).
- Инструменты: `avr-gcc`, `avr-objcopy`, `avrdude` (или аналоги из AVR-GNU Toolchain).

---

## Функциональность

- **Timer1 (CTC, /8)** периодически печатает `TIMER1_STR` (по умолчанию `"ping1"`).  
- **Timer2 (CTC, /256)** периодически печатает `TIMER2_STR` (по умолчанию `"pong1"`).  
- **Первый байт строки отправляется немедленно** из ISR соответствующего таймера (детерминированный запуск). Остальные байты добирает UDRE-ISR из кольцевого TX-буфера.  
- **Командный интерфейс по UART**: настройка интервалов в микросекундах, замена строк (до 31 байта), перезагрузка таймеров.

---

## Пины и подключение

- **TXD (PD1)** → вход адаптера USB-UART (RX).  
- **RXD (PD0)** ← выход адаптера USB-UART (TX), если планируете отправлять команды.  
- Общая земля (GND) должна быть общей между платой и USB-UART.

---

## Сборка и прошивка

Файл исходника: **`main.asm`** (ASM для `avr-gcc`).

```bash
# 1) Сборка (avr-gcc как драйвер ассемблера)
avr-gcc -mmcu=atmega8 -Os -x assembler-with-cpp -o main.elf main.asm

# 2) Генерация .hex
avr-objcopy -O ihex -R .eeprom main.elf main.hex

# 3) Прошивка (пример для USBasp; укажите свой программатор и порт)
avrdude -c usbasp -p m8 -U flash:w:main.hex
```

> Убедитесь, что тактирование действительно 16 MHz (фьюзы под внешний кварц/резонатор, CKDIV8=0).

---

## Константы и конфигурация

В начале `main.asm`:

```asm
.equ F_CPU              = 16000000
.equ BAUD               = 115200
.equ UBRR_VAL           = 16

; Интервалы по умолчанию (в микросекундах):
.equ TIMER1_INTERVAL    = 1000    ; 1.000 ms
.equ TIMER2_INTERVAL    = 1000    ; 1.000 ms
```

Строки по умолчанию записываются в SRAM как:
- `TIMER1_STR = "ping1"`, длина `T1_LEN = 5`
- `TIMER2_STR = "pong1"`, длина `T2_LEN = 5`

Размеры буферов:
```asm
.equ UART_TX_SZ = 128
.equ UART_RX_SZ = 64
```

---

## Команды по UART

Отправляйте ASCII-строки, завершая `` или `
`. На успех — ответ `OK
`, при нарушении критериев — `ERR
`.

- `T1=NNNN` — установить интервал **Timer1** в микросекундах (1..32767).  
- `T2=NNNN` — установить интервал **Timer2** в микросекундах (диапазон ограничен шагом/разрядностью OCR2 при /256).  
- `S1=STRING` — заменить строку **Timer1** (до 31 байта).  
- `S2=STRING` — заменить строку **Timer2** (до 31 байта).  
- `R` — перезагрузить счётчики `TCNT1/TCNT2` (фаза пересобирается), таймеры **не** останавливаются.

### Пример сессии

```
S1=ping1
OK
S2=pong1
OK
T1=868
OK
T2=864
OK
R
OK
```

В терминале параллельно побегут:
```
ping1pong1ping1pong1...
```

---

## Критерии выполнимости (проверка «на лету»)

Перед применением новых параметров выполняются 2 условия:

1) **Само-неперекрытие** каждым потоком собственной строки:
```
T1_us ≥ L1 * Tchar    и    T2_us ≥ L2 * Tchar,
где Tchar ≈ 87 мкс (115200 бод, 8N1), L — длина строки в байтах.
```

2) **Пропускная способность UART**:
```
L1 * (1e6 / T1_us) + L2 * (1e6 / T2_us) ≤ 11520  байт/с
```

Если любое условие нарушается, параметры **не применяются**, возвращается `ERR`.

---

## Точность ≤ 4 тактов (пояснение для «средней сложности»)

- Момент старта передачи **первого байта** строки формируется непосредственно в обработчике сравнения таймера (ISR OCn).  
- Внутренний путь входа в ISR даёт **фиксированную** (константную) задержку, а не случайный разброс.  
- Дополнительно проверяется готовность регистра передачи (`UDRE`), и при готовности байт складывается в `UDR` **внутри ISR** — это даёт **детерминированный старт** с джиттером в пределах нескольких тактов (≤ 4 тактов).  
- Остальные байты строки обслуживаются UDRE-ISR из TX-буфера (на точность старта это уже не влияет).

---

## Минимальная сумма интервалов

Для строк по умолчанию `L1=L2=5`, скорость 115200 8N1 → **11520 байт/с**.

Оптимально симметрично: `T1 = T2 = T`.

\[
\frac{5}{T} + \frac{5}{T} \le 11520
\;\Rightarrow\;
T \ge \frac{10}{11520} \approx 0{.}000868 \text{ с} = 868 \text{ мкс}
\]

**Минимальная сумма**:  
\[
T_1 + T_2 \approx 1736 \text{ мкс}.
\]

В прошивке можно установить близкие значения командами `T1=868`, `T2=864..880` (Timer2 квантуется шагом 16 мкс при /256, см. ограничения ниже) — при выполнении критериев будет `OK`.

---

## Ограничения и примечания

- **Timer1**: CTC, делитель **/8**, шаг таймера **0.5 мкс** (OCR1A — 16-бит).  
- **Timer2**: CTC, делитель **/256**, шаг таймера **16 мкс** (OCR2 — 8-бит). Это сознательный компромисс: точность «стартового байта» обеспечивается ISR-путём, а не шагом OCR2.  
- Диапазон `T2` ограничен шагом 16 мкс и 8-битным OCR2 (примерно 16…65520 мкс).  
- При совпадении событий двух таймеров в один такт возможно перераспределение порядка отправок, но за счёт критериев пропускной способности UART переполнения не происходит, а старт следующего «первого байта» остаётся детерминированным.

---

## Структура проекта

```
.
├── main.asm        # Исходник прошивки (ASM для avr-gcc)
└── README.md       # Этот файл
```

---

## Лицензия

MIT — делайте с кодом что хотите, но без гарантий.  
(При необходимости замените на вашу корпоративную лицензиию/нотис.)

---

### Соответствие уровням задания (чек-лист)

- [x] **Стандартная сложность**: 2 таймера, `"ping1"`/`"pong1"`, интервалы из констант.  
- [x] **Средняя сложность**: детерминированный запуск передачи первого байта в ISR таймера; расчёт минимальной суммы интервалов.  
- [x] **Высокая сложность**: команды `T1=`, `T2=`, `S1=`, `S2=`, `R`; онлайн-валидация и `ERR` при невозможности, без остановки таймеров.
