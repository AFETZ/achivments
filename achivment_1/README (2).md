Пояснение к проекту (ATmega8, 16 МГц)
=====================================

Цель: два независимых таймера периодически печатают в UART строки — по умолчанию **“ping1”** и **“pong1”**. 

---

1) Что происходит
------------------------------------



* Два таймера (CTC-режим) «стреляют» по своим периодам.  
* В **самом** обработчике таймера кладём **первый байт** сразу в регистр `UDR`, если `UDRE=1` (готов к передаче).  
* Остальные байты строки попадают в кольцевой буфер, их добирает прерывание **UDRE**.  
* Команды с ПК принимаются через RX (есть кольцевой буфер и простой парсер). Таймеры **не останавливаются** во время вычислений и проверки параметров.

---

2) Таймеры и интервалы
----------------------

- **Timer1:** CTC, делитель **/8**, шаг 0.5 мкс (удобно для мелких периодов).  
- **Timer2:** CTC, делитель **/256**, шаг 16 мкс (грубее, но не мешает точному запуску первого байта).  
- Константы в коде: `TIMER1_INTERVAL` и `TIMER2_INTERVAL` — **в микросекундах**.  
  Под капотом они переводятся в `OCR1A` и `OCR2`:
  - `OCR1A = T1_us * 2 − 1`
  - `OCR2  = T2_us / 16 − 1` (с округлением по шагу 16 мкс)

Замена интервалов на лету делается командами `T1=...` и `T2=...` без остановки таймеров. Сброс фазы — командой `R` (обнуляет `TCNT1/TCNT2`).

---

3) Почему «точность до 4 тактов» выполняется (средний уровень)
---------------------------------------------------------------

Требование тут про **момент старта вывода**. Мы отправляем **первый байт** строки **прямо в ISR таймера**.  
Вход в ISR имеет фиксированную машинную задержку (одинаковую каждый раз), поэтому **джиттер** (разброс старта) сводится к нескольким тактам.  
Сам символ дальше «едет» по UART, но старт **детерминированный**. Остальные байты идут через UDRE — на точность старта это уже не влияет.

> Случай «оба таймера сработали в один такт» допускается: сначала обслужится один ISR, затем второй. Это добавляет **константную** задержку, но не создаёт случайного разброса — требование по смыслу сохраняется.

---

4) Минимальная сумма интервалов (средний уровень)
--------------------------------------------------

Скорость 115200 бод (8N1) ≈ **11520 байт/с**. Один символ ~**87 мкс**.  
Для строк по 5 байт: оптимум симметричный (`T1 = T2 = T`):

```
5/T + 5/T ≤ 11520  ⇒  T ≥ 10/11520 ≈ 0.000868 с = 868 мкс
Минимальная сумма: T1 + T2 ≈ 1736 мкс
```

На практике ставим, например:
```
T1=868
T2=864   ; у Timer2 шаг 16 мкс, поэтому 864 или 880 — оба подходят
```
Если критерии выполняются — прошивка вернёт `OK` и начнёт печатать устойчиво.

---

5) Проверка «выполнимости» настроек (высокий уровень)
-----------------------------------------------------

Перед применением новых значений прошивка проверяет **два условия**:

1. **Пер-поток** (чтобы поток не «догонял» сам себя):  
   `T_us ≥ L * 87 мкс`, где `L` — длина строки (в байтах).
2. **Суммарная скорость не больше UART:**  
   `L1*(1e6/T1_us) + L2*(1e6/T2_us) ≤ 11520 байт/с`

Если что-то не сходится — ответ `ERR` и параметры **не применяются**. Таймеры при этом **не останавливаются**.

---

6) Команды для проверки (высокий уровень)
-----------------------------------------

Строки ASCII, конец — `\r` или `\n`. Ответы: `OK\r\n` или `ERR\r\n`.

- `T1=NNNN` — задать период Timer1 в микросекундах (типичный диапазон 1…32767).  
- `T2=NNNN` — период Timer2 в микросекундах (шаг 16 мкс, диапазон примерно 16…65520).  
- `S1=STRING` — строка для Timer1 (до 31 байта).  
- `S2=STRING` — строка для Timer2 (до 31 байта).  
- `R` — сброс `TCNT1/TCNT2` (без остановки).

Быстрый тест «на ошибку»:  
```
S1=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   ; 31 байт
T1=100                               ; 100 мкс явно меньше 31*87 мкс → ERR
```

---


7) Что считать «выполнено» по уровням
-------------------------------------

**Стандартная сложность**
- Два таймера в CTC, интервалы заданы константами `TIMER1_INTERVAL` / `TIMER2_INTERVAL` (в мкс).
- При срабатывании соответствующего таймера в UART печатается нужная строка (`TIMER1_STR` = “ping1”, `TIMER2_STR` = “pong1”).

**Средняя сложность**
- Старт первого байта — **внутри ISR таймера** (детерминированно, без лишнего джиттера).  
- Приведён расчёт минимальной **суммы интервалов** — ≈ **1.736 мс** и показано, как её достичь с учётом шага Timer2.

**Высокая сложность**
- Команды по UART: `T1=`, `T2=`, `S1=`, `S2=`, `R`.  
- Перед применением — проверка выполнимости (2 критерия выше).  
- На время вычислений таймеры **не останавливаются**. При невозможности — печать `ERR`.

