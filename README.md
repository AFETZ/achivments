# AVR Timers “Ping–Pong” (ATmega8, AVR Assembler)

Два таймера (Timer1 16‑бит, Timer2 8‑бит) работают параллельно в режиме CTC и при срабатывании отправляют строки по USART:
- `TIMER1_STR = "ping1"`
- `TIMER2_STR = "pong1"`

Передача реализована неблокирующе: прерывания таймеров **кладут события в очередь**, а отправка идёт из прерывания `UDRE` (передатчик пуст) из **кольцевого буфера**. Так выдерживается точность и не “душится” UART длинными строками.

## Параметры по умолчанию
- Тактирование: `F_CPU = 16_000_000` Гц
- UART: `115200 8N1`, `U2X=1`
- Timer1: CTC, прескалер `/8`, `OCR1A = 2000-1` (≈1.0 мс)
- Timer2: CTC, прескалер `/128`, `OCR2 = 125-1` (≈1.0 мс)

## Сборка (avr-gcc, avr-libc)
```bash
avr-gcc -mmcu=atmega8 -Os -x assembler-with-cpp ping_pong.asm -o ping_pong.elf
avr-objcopy -O ihex ping_pong.elf ping_pong.hex
```
Прошивка (пример для usbasp):
```bash
avrdude -p m8 -c usbasp -U flash:w:ping_pong.hex
```

## Пояснения к “средней сложности”
Пропускная способность `8N1` ≈ `BAUD/10` байт/с. Для строк по 5 байт минимальная сумма периодов, при которой UART гарантированно успевает:
```
T1 = T2 ≥ 10 / (BAUD/10) = 10 / 11520 ≈ 0.000868 c  → сумма ≈ 1.736 мс
```
В коде это ~`OCR1A≈1736-1` при тике 0.5 мкс и `OCR2≈109-1` при тике 8 мкс.

## Файлы
- `ping_pong.asm` — исходник AVR ASM (ATmega8)
- `README.md` — это описание

Готово к проверке: откройте Serial 115200 8N1 и наблюдайте `"ping1"`/`"pong1"` с заданными интервалами.
